<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Racing Scene</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute; top: 10px; left: 10px;
      color: #fff; z-index: 1;
      background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px;
    }
    input[type=color], label { vertical-align: middle; margin-right: 10px; }
  </style>
</head>
<body>
<div id="overlay">
  <label>Body: <input type="color" id="body-color" value="#ff0000"></label>
  <label>Details: <input type="color" id="details-color" value="#ffffff"></label>
  <label>Glass: <input type="color" id="glass-color" value="#ffffff"></label>
</div>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@latest/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

// Scene and Camera Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x333333);
scene.environment = new RGBELoader().load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr');
scene.environment.mapping = THREE.EquirectangularReflectionMapping;

const camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 5, -10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.85;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.maxPolarAngle = Math.PI / 2;
controls.target.set(0, 0.5, 0);
controls.update();

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

// Road
const road = new THREE.Mesh(
  new THREE.PlaneGeometry(6, 200, 1, 20),
  new THREE.MeshStandardMaterial({ color: 0x555555 })
);
road.rotation.x = -Math.PI / 2;
road.position.z = 50;
scene.add(road);

// White edge lines
[-3, 3].forEach(x => {
  const edge = new THREE.Mesh(
    new THREE.PlaneGeometry(0.2, 200),
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  edge.position.set(x, 0.01, 50);
  edge.rotation.x = -Math.PI / 2;
  scene.add(edge);
});

// Buildings
for (let z = -50; z < 150; z += 20) {
  [-6, 6].forEach(x => {
    const h = 10 + Math.random() * 10;
    const b = new THREE.Mesh(
      new THREE.BoxGeometry(4, h, 4),
      new THREE.MeshStandardMaterial({ color: 0x888888 })
    );
    b.position.set(x, h / 2, z);
    scene.add(b);
  });
}

// Street & Traffic Lights
const poleMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
for (let z = -50; z < 150; z += 40) {
  [-2.5, 2.5].forEach(x => {
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 8), poleMat);
    pole.position.set(x, 4, z);
    scene.add(pole);
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
    bulb.position.set(x, 8, z);
    scene.add(bulb);
  });
}
const traffic = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0x000000 }));
traffic.position.set(4, 1, 0);
scene.add(traffic);
['red','yellow','green'].forEach((clr, idx) => {
  const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: clr==='red'?0xff0000: clr==='yellow'?0xffff00:0x00ff00 }));
  bulb.position.set(4, 2.2 - idx * 0.8, 0.3);
  scene.add(bulb);
});

// Car Model and Materials (via Three.js materials-car example)
const bodyMat = new THREE.MeshPhysicalMaterial({ color: 0xff0000, metalness: 1, roughness: 0.5, clearcoat: 1, clearcoatRoughness: 0.03 });
const detailMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1, roughness: 0.5 });
const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1 });

['body-color','details-color','glass-color'].forEach((id, idx) => {
  document.getElementById(id).addEventListener('input', (e) => {
    [bodyMat, detailMat, glassMat][idx].color.set(e.target.value);
  });
});

const draco = new DRACOLoader();
draco.setDecoderPath('https://unpkg.com/three@latest/examples/jsm/libs/draco/gltf/');

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);
loader.load('https://threejs.org/examples/models/gltf/ferrari.glb', (gltf) => {
  const car = gltf.scene.children[0];
  car.getObjectByName('body').material = bodyMat;
  car.getObjectByName('rim_fl').material = detailMat;
  car.getObjectByName('rim_fr').material = detailMat;
  car.getObjectByName('rim_rl').material = detailMat;
  car.getObjectByName('rim_rr').material = detailMat;
  car.getObjectByName('trim').material = detailMat;
  car.getObjectByName('glass').material = glassMat;

  car.position.set(0, 0, 0);
  scene.add(car);
  animateCar(car);
});

const wheels = [];
function animateCar(car) {
  ['wheel_fl', 'wheel_fr', 'wheel_rl', 'wheel_rr'].forEach(name => {
    const w = car.getObjectByName(name);
    if (w) wheels.push(w);
  });
}

// Animation loop
function animate(time) {
  time = time * 0.001;
  road.position.z = (time * 20) % 100;
  renderer.render(scene, camera);
  wheels.forEach(w => w.rotation.x = time * Math.PI * 2);
  controls.update();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
